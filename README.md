    public class JvmComprehension {
    
        public static void main(String[] args) {
            int i = 1;                      // 1 Примитивный тип данных (4 байта), хранится в стэке.
            Object o = new Object();        // 2 Ссылочный тип данных, созданный объект хранится в хипе, ссылка на него хранится в стэке, выделяет место в хипе под размер этото объекта
            Integer ii = 2;                 // 3 Объект,передающий значение 2, хранится в хипе, ссылка на него - в стэке, ссылка на этот объект в памяти передается в переменную ii
            printAll(o, i, ii);             // 4 Новый фрейм, который находится над main, при вызове метода - создаётся фрейм этого метода и пушиться на верх стека. Передача в него всех 3 переменных
            System.out.println("finished"); // 7 Создается новый фрейм println, создается строка (находится в хипе, а ссылка на нее в стэке), которая выводится на экран. Метод завершается - фрейм закрывается. Метод main и фрейм main завершают свою работу.
        }
    
        private static void printAll(Object o, int i, Integer ii) {  - создание переменных заново, копирование ссылок в эту область памяти 
            Integer uselessVar = 700;                   // 5 Создание новой переменной ссылочного типа в фрейме printAll, значение 700 хранится в хипе, а ссылка на него - в стеке
            System.out.println(o.toString() + i + ii);  // 6 Вызов метода System.out.println, создание нового фрейма, все переменные в виде строк хранятся в хипе, "склеиваются", результат в хипе, это будет выглядеть на экране как одно значение, передача в метод println, вывод на экран значения и закрытие фрейма.
        }
    }
Для классов Object, Integer, System, String  - для всех них ClassLoaderы ищет эти классы.
Сборщик мусора определяет, какие объекты используются, а какие нет, ненужные удаляет (к примеру uselessVar - ее он удалит в 1 очередь).
В конце программы после вызова метода System.out.println сборщик мусора удаляет из хипа все данные, стек опустошается. 